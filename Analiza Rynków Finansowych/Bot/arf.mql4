extern int min_gapsize = 1;
extern double lotsize_gap = 0.2;
datetime order_time = 0;


int init() { return(0); }
int deinit() { return(0); }


int start() {
  // Defining the variables to decide.
  Print("order time", order_time);
  double current_openprice = iOpen(Symbol(), PERIOD_M30, 0);
  double previous_highprice = iHigh(Symbol(), PERIOD_M30, 1);
  double previous_lowprice = iLow(Symbol(), PERIOD_M30, 1);
  double point_gap = MarketInfo(Symbol(), MODE_POINT);
  int spread_gap = MarketInfo(Symbol(), MODE_SPREAD);
  datetime current_time = iTime(Symbol(), PERIOD_M30, 0);
   
  // Catching the gap on sell upper gap
  if (current_openprice > previous_highprice + (min_gapsize + spread_gap) * point_gap
        && current_time != order_time) {


    int ticket = OrderSend(Symbol(), OP_SELL, lotsize_gap, Bid, 0, 0,
                             previous_highprice + spread_gap*point_gap, "", 4, 0, Red);


    order_time = iTime(Symbol(), PERIOD_M30, 0);
    Print("I am inside (sell)", order_time);
   
    if (ticket < 0) {
        Print("OrderSend failed with error: ", GetLastError());
    }
  }
     
  // Catching the gap on buy down gap
  if (current_openprice < previous_lowprice - (min_gapsize + spread_gap) * point_gap
        && current_time != order_time) {
    ticket = OrderSend(Symbol(), OP_BUY, lotsize_gap, Ask, 0, 0,
                        previous_lowprice - spread_gap*point_gap, "", 5, 0, Green);
                       
    order_time = iTime(Symbol(), PERIOD_M30, 0);
    Print("I am inside (buy)", order_time);
    if (ticket < 0) {
      Print("OrderSend failed with error #", GetLastError());
    }
  }
  return(0);
}